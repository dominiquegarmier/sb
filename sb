#!/bin/bash
set -e

# Load config if exists
CONFIG_FILE="${HOME}/.config/sb/config"
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

# Parse flags, everything after -- becomes the command
EPHEMERAL=false
FORWARD_DOCKER=false
REBUILD=false
CMD=()
while [[ $# -gt 0 ]]; do
    case $1 in
        --rm) EPHEMERAL=true; shift ;;
        --forward-docker) FORWARD_DOCKER=true; shift ;;
        --rebuild) REBUILD=true; shift ;;
        --) shift; CMD=("$@"); break ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
done

IMAGE_NAME="sb:latest"
PROJECT_DIR="$(pwd)"
DOCKERFILE_PATH="${HOME}/.config/sb/Dockerfile"

# Use hash of absolute path for unique naming
PROJECT_HASH="$(echo -n "$PROJECT_DIR" | shasum -a 256 | cut -c1-12)"
VOLUME_NAME="sb-${PROJECT_HASH}"
CONTAINER_NAME="sb-${PROJECT_HASH}"
SYNC_NAME="sb-${PROJECT_HASH}"

# Check mutagen
if ! command -v mutagen &> /dev/null; then
    echo "Error: Mutagen is required but not installed."
    echo ""
    echo "Install with:"
    echo "  macOS:  brew install mutagen-io/mutagen/mutagen"
    echo "  Linux:  See https://mutagen.io/documentation/introduction/installation"
    exit 1
fi

# Rebuild: remove everything and start fresh
if [[ "$REBUILD" == "true" ]]; then
    echo "Rebuilding (this will delete all container state)..."
    mutagen sync terminate "$SYNC_NAME" &>/dev/null || true
    docker stop "$CONTAINER_NAME" &>/dev/null || true
    docker rm "$CONTAINER_NAME" &>/dev/null || true
    docker volume rm "$VOLUME_NAME" &>/dev/null || true
    docker rmi "$IMAGE_NAME" &>/dev/null || true
fi

# Build image if needed
if [[ -z "$(docker images -q "$IMAGE_NAME" 2>/dev/null)" ]]; then
    if [[ ! -f "$DOCKERFILE_PATH" ]]; then
        echo "Error: Dockerfile not found at $DOCKERFILE_PATH"
        echo "Run the install script again to download it."
        exit 1
    fi
    echo "Building $IMAGE_NAME (may take a few minutes)..."
    docker build -t "$IMAGE_NAME" -f "$DOCKERFILE_PATH" "$(dirname "$DOCKERFILE_PATH")"
fi

mkdir -p ~/.claude ~/.codex

# Build docker run args
DOCKER_ARGS=(
    -d
    -v "$VOLUME_NAME:/workspace"
    -v "$HOME/.claude:/root/.claude"
    -v "$HOME/.codex:/root/.codex"
    -e GH_TOKEN="${GH_TOKEN:-$GITHUB_TOKEN}"
)
if [[ "$FORWARD_DOCKER" == "true" ]]; then
    DOCKER_ARGS+=(-v /var/run/docker.sock:/var/run/docker.sock)
fi

# Cleanup on exit
cleanup() {
    echo ""
    mutagen sync terminate "$SYNC_NAME" &>/dev/null || true
    if [[ "$EPHEMERAL" == "true" ]]; then
        echo "Cleaning up..."
        docker stop "$CONTAINER_NAME" &>/dev/null || true
        docker rm "$CONTAINER_NAME" &>/dev/null || true
        docker volume rm "$VOLUME_NAME" &>/dev/null || true
    else
        echo "Detaching (container keeps running)..."
    fi
}
trap cleanup EXIT INT TERM

if [[ "$EPHEMERAL" == "true" ]]; then
    # Ephemeral mode: remove existing and create fresh
    docker stop "$CONTAINER_NAME" &>/dev/null || true
    docker rm "$CONTAINER_NAME" &>/dev/null || true
    docker volume rm "$VOLUME_NAME" &>/dev/null || true
    echo "Creating ephemeral container..."
    docker volume create "$VOLUME_NAME" &>/dev/null || true
    docker run "${DOCKER_ARGS[@]}" --name "$CONTAINER_NAME" "$IMAGE_NAME" tail -f /dev/null
else
    # Persistent mode: reuse existing container
    CONTAINER_EXISTS=$(docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$" && echo "yes" || echo "no")
    CONTAINER_RUNNING=$(docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$" && echo "yes" || echo "no")

    if [[ "$CONTAINER_RUNNING" == "yes" ]]; then
        echo "Container already running..."
    elif [[ "$CONTAINER_EXISTS" == "yes" ]]; then
        echo "Starting existing container..."
        docker start "$CONTAINER_NAME" >/dev/null
    else
        echo "Creating new container..."
        docker volume create "$VOLUME_NAME" &>/dev/null || true
        docker run "${DOCKER_ARGS[@]}" --name "$CONTAINER_NAME" "$IMAGE_NAME" tail -f /dev/null
    fi
fi

# Collect ignore patterns from .gitignore files
collect_gitignore_patterns() {
    local ignores=()
    local found_gitignore=false

    # Read global gitignore
    local global_gitignore
    global_gitignore="$(git config --global core.excludesFile 2>/dev/null || true)"
    # Expand ~ if present
    global_gitignore="${global_gitignore/#\~/$HOME}"
    if [[ -n "$global_gitignore" && -f "$global_gitignore" ]]; then
        found_gitignore=true
        while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            line="${line%"${line##*[![:space:]]}"}"
            [[ -z "$line" ]] && continue
            local negate=""
            if [[ "$line" =~ ^! ]]; then
                negate="!"
                line="${line#!}"
            fi
            line="${line#/}"
            ignores+=("--ignore=${negate}${line}")
        done < "$global_gitignore"
    fi

    # Find all .gitignore files in project
    while IFS= read -r -d '' gitignore; do
        found_gitignore=true
        local rel_dir
        rel_dir="$(dirname "${gitignore#$PROJECT_DIR/}")"
        [[ "$rel_dir" == "$gitignore" ]] && rel_dir="."

        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            # Trim trailing whitespace
            line="${line%"${line##*[![:space:]]}"}"
            [[ -z "$line" ]] && continue

            # Handle negation (mutagen supports this with !)
            local negate=""
            if [[ "$line" =~ ^! ]]; then
                negate="!"
                line="${line#!}"
            fi

            if [[ "$rel_dir" == "." ]]; then
                # Root .gitignore: pass patterns as-is
                line="${line#/}"  # Remove leading slash
                ignores+=("--ignore=${negate}${line}")
            else
                # Nested .gitignore: scope patterns to subdirectory
                if [[ "$line" =~ ^/ ]]; then
                    # /pattern -> dir/pattern
                    ignores+=("--ignore=${negate}${rel_dir}${line}")
                elif [[ "$line" =~ / ]]; then
                    # path/pattern -> dir/path/pattern
                    ignores+=("--ignore=${negate}${rel_dir}/${line}")
                else
                    # pattern -> dir/**/pattern (match anywhere under dir)
                    ignores+=("--ignore=${negate}${rel_dir}/**/${line}")
                fi
            fi
        done < "$gitignore"
    done < <(find "$PROJECT_DIR" -name .gitignore -print0 2>/dev/null)

    # Fallback defaults if no .gitignore found
    if [[ "$found_gitignore" == "false" ]]; then
        ignores+=("--ignore=.venv")
        ignores+=("--ignore=__pycache__")
        ignores+=("--ignore=*.pyc")
        ignores+=("--ignore=node_modules")
        ignores+=("--ignore=target")
        ignores+=("--ignore=build")
    fi

    printf '%s\n' "${ignores[@]}"
}

# Check if sync session exists
SYNC_EXISTS=$(mutagen sync list | grep -q "$SYNC_NAME" && echo "yes" || echo "no")

if [[ "$SYNC_EXISTS" == "yes" ]]; then
    echo "Resuming file sync..."
    mutagen sync resume "$SYNC_NAME" &>/dev/null || true
else
    echo "Starting file sync..."

    # Build ignore flags from .gitignore files
    IGNORE_FLAGS=()
    while IFS= read -r flag; do
        [[ -n "$flag" ]] && IGNORE_FLAGS+=("$flag")
    done < <(collect_gitignore_patterns)

    mutagen sync create \
        --name="$SYNC_NAME" \
        --sync-mode=two-way-resolved \
        --default-file-mode=0644 \
        --default-directory-mode=0755 \
        "${IGNORE_FLAGS[@]}" \
        "$PROJECT_DIR" \
        "docker://${CONTAINER_NAME}/workspace"
fi

echo "Waiting for sync..."
mutagen sync flush "$SYNC_NAME"

echo ""
if [[ ${#CMD[@]} -eq 0 ]]; then
    docker exec -it "$CONTAINER_NAME" /bin/bash
else
    docker exec -it "$CONTAINER_NAME" "${CMD[@]}"
fi
